length = 20;
width = 10;

grid = world.getCurrentGrid();
piece = world.getCurrentPiece();
npiece = world.getNextPiece();

int[][] r1;
int[][] c1;
int[][] r2;
int[][] c2;

r1 = new int[4][4];
c1 = new int[4][4];
r2 = new int[4][4];
c2 = new int[4][4];

void getCoordinates(int[] r, int[] c, int[][] piece) {
    int s = 0;
    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
            if (piece[i][j] == 1) {
                r[s] = i;
                c[s] = j;
                s++;
            }
}

for (int i = 0; i < 4; ++i) {
    getCoordinates(r1[i], c1[i], piece);
    world.rotatePiece(1);
    piece = world.getCurrentPiece();
}

int[][] rotatePiece(int[][] piece) {
    int[][] ret = new int[4][4];
    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j) {
            ret[j][4 - i - 1] = piece[i][j];
        }
    return ret;
}

for (int i = 0; i < 4; ++i) {
    getCoordinates(r2[i], c2[i], npiece);
    npiece = rotatePiece(npiece);
}

boolean canFit(int r, int c, int[][] r1, int[][] c1, int dir, int[][] grid) {
    for (int i = 0; i < 4; ++i) {
        int nr = r + r1[dir][i];
        int nc = c + c1[dir][i];
        if (nr >= length) return false;
        if (nc >= width) return false;
        if (grid[nr][nc] == 1)
            return false;
    }
    return true;
}

// left, right, rotate, down
int[] dr = { 0, 0, 0, 1};
int[] dc = {-1, 1, 0, 0};
int[] dd = { 0, 0, 1, 0};

void solve(int[][] r1, int[][] c1, int[] fRow, int[] fCol, int[] fRot, int[] fsz, int[][] grid, int[][][] from) {
    boolean[][][] can;
    can = new boolean[length][width][4];

    for (int r = 0; r < length; ++r)
        for (int c = 0; c < width; ++c)
            for (int rotation = 0; rotation < 4; ++rotation) {
                if (canFit(r, c, r1, c1, rotation, grid))
                    can[r][c][rotation] = true;
            }

    boolean[][][][] edgeCan = new boolean[length][width][4][4];

    for (int r = 0; r < length; ++r)
        for (int c = 0; c < width; ++c)
            for (int rot = 0; rot < 4; ++rot) {
                for (int dir = 0; dir < 4; ++dir) {
                    if (c != 0 && dir == 2) continue;
                    int nr = r + dr[dir];
                    int nc = c + dc[dir];
                    int nrot = rot + dd[dir];
                    if (nr < 0 || nr >= length) continue;
                    if (nc < 0 || nc >= width) continue;
                    if (nrot == 4) nrot = 0;
                    if (!can[nr][nc][nrot]) continue;

                    edgeCan[r][c][rot][dir] = true;
                }
            }

    int qsize = 0;
    int[] queue = new int[length * width * 4 * 3];
    boolean[][][] mark = new boolean[length][width][4];

    mark[0][4][0] = true;
    queue[qsize++] = 0;
    queue[qsize++] = 4;
    queue[qsize++] = 0;
    from[0][4][0] = -1;

    for (int cur = 0; cur < qsize;) {
        int curRow = queue[cur++];
        int curCol = queue[cur++];
        int curRot = queue[cur++];
        for (int dir = 0; dir < 4; ++dir) {
            if (edgeCan[curRow][curCol][curRot][dir]) {
                int newRow = curRow + dr[dir];
                int newCol = curCol + dc[dir];
                int newRot = curRot + dd[dir];
                if (newRot == 4) newRot = 0;
                if (!mark[newRow][newCol][newRot]) {
                    mark[newRow][newCol][newRot] = true;
                    from[newRow][newCol][newRot] = dir;
                    queue[qsize++] = newRow;
                    queue[qsize++] = newCol;
                    queue[qsize++] = newRot;
                }
            }
        }
    }

    fsz[0] = 0;
    for (int i = 0; i < length; ++i)
        for (int j = 0; j < width; ++j)
            for (int rot = 0; rot < 4; ++rot) {
                if (mark[i][j][rot]) {
                    if (!edgeCan[i][j][rot][3]) {
                        fRow[fsz[0]] = i;
                        fCol[fsz[0]] = j;
                        fRot[fsz[0]] = rot;
                        fsz[0]++;
                    }
                }
            }
}

int evaluation2(int[][] grid, int offset) {
    /*
    int c1 = -371;
    int c2 = -479;
    int c3 = 140;
    int c4 = -187;
    int c5 = 480;
    int c6 = 322;
    int c7 = 368; */
    
    int c1 = -30; // Height
    int c2 = -75; // Holes
    int c3 = -35; // Blockades
    int c4 = 80;  // Clears
    int c5 = 30;  // Blocks
    int c6 = 25;  // Walls
    int c7 = 50;  // Floors
    
    int res = 0, num = 0;    
    for (int i = 0; i < 20; i++)
        for (int j = 0; j < 10; j++) {
            if (grid[i][j] == 1) num += 19 - i;
        }
    res += c1 * num; // Height
    
    num = 0;

    for (int j = 0; j < 10; j++) {
        int b = 0;

        for (int i = 0; i < 20; i++) {
            if (grid[i][j] == 1) b = 1;
            if (grid[i][j] == 0 && b == 1) num++;
        }
    }
    res += c2 * num; // Holes
    
    num = 0;

    for (int j = 0; j < 10; j++) {
        int b = 0;
        for (int i = 19; i >= 0; i--) {
            if (grid[i][j] == 0) b = 1;
            if (grid[i][j] == 1 && b == 1) num++;
        }
    }
    res += c3 * num; //Blockades
    
    res += c4 * offset; // Clears
    
    int block = 0, wall = 0, floors = 0;
    for (int i = 1; i < 19; i++) {
        if (grid[i][0] == 1) wall++;
        if (grid[i][9] == 1) wall++;
        if (grid[i][0] == 1 && grid[i-1][0] == 1) block++;
        if (grid[i][9] == 1 && grid[i-1][9] == 1) block++;
        if (grid[i][0] == 1 && grid[i+1][0] == 1) block++;
        if (grid[i][9] == 1 && grid[i+1][9] == 1) block++;
        if (grid[i][0] == 1 && grid[i][1] == 1) block++;
        if (grid[i][9] == 1 && grid[i][8] == 1) block++;
    }
    if (grid[19][0] == 1 && grid[18][0] == 1) block++;
    if (grid[19][9] == 1 && grid[18][9] == 1) block++;
    if (grid[19][0] == 1 && grid[19][1] == 1) block++;
    if (grid[19][9] == 1 && grid[19][8] == 1) block++;
    
    
    for (int j = 0; j < 10; j++) if (grid[19][j] == 1) floors++;

    
    for (int i = 1; i < 19; i++)
        for (int j = 1; j < 9; j++)
            if (grid[i][j] == 1) {
                if (grid[i+1][j] == 1) block++;
                if (grid[i-1][j] == 1) block++;
                if (grid[i][j+1] == 1) block++;
                if (grid[i][j-1] == 1) block++;
            }
    
    res += c5 * block;
    res += c6 * wall;
    res += c7 * floors;
    res = -res;
    return res;
}

int[][] update(int[][] grid, int[] a) {
    int[][] ret = new int[length][width];
    int offset = 0;
    for (int i = length - 1; i >= 0; --i) {
        boolean delRow = true;
        for (int j = 0; j < width; ++j)
            if (grid[i][j] == 0)
                delRow = false;
        if (delRow) ++offset;
        else {
            for (int j = 0; j < width; ++j)
                ret[i + offset][j] = grid[i][j];
        }
    }
    a[0] = offset;
    return ret;
}

int[] fsz = new int[1];
int[] fRow = new int[length * width * 4];
int[] fCol = new int[length * width * 4];
int[] fRot = new int[length * width * 4];
int[][][] from = new int[length][width][4];
solve(r1, c1, fRow, fCol, fRot, fsz, grid, from);

int[] fsz2 = new int[1];
int[] fRow2 = new int[length * width * 4];
int[] fCol2 = new int[length * width * 4];
int[] fRot2 = new int[length * width * 4];
int[][][] from2 = new int[length][width][4];

int idx = 0;
int best = 1000000;
int[][] ngrid = new int[length][width];
int[][] ngrid2 = new int[length][width];

for (int tr = 0; tr < fsz[0]; ++tr) {
    for (int i = 0; i < length; ++i)
        for (int j = 0; j < width; ++j)
            ngrid[i][j] = grid[i][j];
    for (int i = 0; i < 4; ++i)
        ngrid[fRow[tr] + r1[fRot[tr]][i]][fCol[tr] + c1[fRot[tr]][i]] = 1;
    int[] a = new int[1];
    ngrid = update(ngrid, a);
    solve(r2, c2, fRow2, fCol2, fRot2, fsz2, ngrid, from2);
    //System.out.println(fsz[0] + " " + fsz2[0]);
    for (int tr2 = 0; tr2 < fsz2[0]; ++tr2) {
        for (int i = 0; i < length; ++i)
            for (int j = 0; j < width; ++j)
                ngrid2[i][j] = ngrid[i][j];
        for (int i = 0; i < 4; ++i)
            ngrid2[fRow2[tr2] + r2[fRot2[tr2]][i]][fCol2[tr2] + c2[fRot2[tr2]][i]] = 1;
        int[] b = new int[1];
        ngrid2 = update(ngrid2, b);
        int tmp = evaluation2(ngrid2, a[0] + b[0]);
        if (tmp < best) {
            idx = tr;
            best = tmp;
        } 
    }
}

int curRow = fRow[idx];
int curCol = fCol[idx];
int curRot = fRot[idx];

int movesCnt = 0;
int[] moves = new int[length * width * 4];

boolean first = false;
while (from[curRow][curCol][curRot] != -1) {
    int f = from[curRow][curCol][curRot];
    if (f == 3 && first == false) first = true;
    else moves[movesCnt++] = f;
    if (f == 0) curCol++;
    else if (f == 1) curCol--;
    else if (f == 2) { curRot--; if (curRot == -1) curRot = 3; }
    else curRow--;
}

int cnt = 0;
for (int i = movesCnt - 1; i >= 0; --i) {
    if (moves[i] == 0) world.moveLeft(1);
    else if (moves[i] == 1) world.moveRight(1);
    else if (moves[i] == 2) world.rotatePiece(1);
    else { if(!world.moveDown(1)) System.out.println("FAIL"); ++cnt; }
}

world.dropPiece();
